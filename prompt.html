<style>
    /* Styling the responsive image grid */
    .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Adjusts column number based on screen width */
        gap: 10px;
    }
    .image-grid img {
        width: 100%;
        height: auto;
        display: block;
    }
    .important {
    background-color: #ffe6e6; 
    border-left: 5px solid #ff4d4d; 
    padding: 10px;
    margin-bottom: 20px;
    color: #000; 
    transition: background-color 0.3s, border-color 0.3s, color 0.3s; 
    } 
     
     .note {
    background-color: #ffe6e6; 
    border-left: 5px solid #4d94ff;
    padding: 10px;
    margin-bottom: 20px;
    color: #000; 
    transition: background-color 0.3s, border-color 0.3s, color 0.3s; 
  }

/* Dark mode */
@media (prefers-color-scheme: dark) {
    .important {
        background-color: #8B0000; 
        border-left: 5px solid #ff7878; 
        color: #fff; 
        width: fit-content;
    }
     .note {
        background-color: #00008B; 
        border-left: 5px solid #4d94ff; 
        color: #fff; 
        width: fit-content;
    }
}
    body {
        margin: 20px;
        font-family: Arial, sans-serif;
    }

.imgcontainer {
    display: flex;
    justify-content: center;
}
</style>

<p> In recent lesson activities, you have 
    been working with Binary Search Trees to store and manage arbitrary data. 
    We know that Binary Search trees allow us to quickly query for nodes of interest, 
    due to their unique organizational property that halves the possible search space at each step in a given traversal.
    <br><br>Recall the BST property is as follows:
</p>
 <div class="note">
        <p>Let x be a node in the BST. If y is a node in the left subtree of x, then y.value < x.value. If y is a node in the right subtree of x, then y.value >= x.value.
        </p>
    </div>
<p>
    Binary Search Trees (and all other variants) also provide additional 
 functionality through the hierarchical ordering of their nodes. 
    This allows us to model a number of interesting structures in which 
    the children of a given parent node are connected by some underlying characteristic. 
    In this activity, we will use a BST to model a Cultivar Group tree. 
</p>

<p>
    A cultivar is a variety of a plant that has been genetically 
    selected for and cultivated by humans due to its expression of desirable or otherwise novel traits. 
    Cultivars are originally derived from a naturally occurring variety of plant. 
    Due to this, cultivar groups lend themselves well to being represented as trees, such as the following example:
</p>


<div class="imgcontainer"><img src="img/cultivar_tree.png" alt=""></div>

<h3>Allowed Headers:</h3>
<p>You may only include the following headers in your solution:</p>
<ul>
  <li><code class="language-cpp">"cultivar_tree.hpp"</code></li>
  <li><code class="language-cpp">"node.hpp"</code></li>
  <li><code class="language-cpp">&lt;ostream&gt;</code></li>
  <li><code class="language-cpp">&lt;fstream&gt;</code></li>
  

  <li><code class="language-cpp">&lt;stdexcept&gt;</code></li>
</ul>

<p>In order to simplify your implementation, 
    we have provided a series of helper functions for your use.
</p>




 <div class="note">
        <h6>Aside: A Note on Resizing Policies</h6>
        <p>For simplicity, we will always reallocate our <i>string_</i> character array to 
          a size large enough to fit <b><i>only</i></b> the characters we are storing and the sentinel value. 
          In practice, this is a rather inefficient 
          policy that requires us to perform a reallocation and 
          copy of the entire existing string every time we wish to append a character or string.
          CS 225 will cover this topic in more depth; please implement the functions as described in this assignment.
        </p>
    </div>

 <div class="important">
        <h6>Important: Memory Management</h6>
        <p>This assignment heavily emphasizes proper memory management in C++. Pay close attention to when and how you allocate, deallocate, and reallocate memory.
        </p>
    </div>

<hr>
<h3>Provided Functions:</h3>
<div class="box">
  <pre><code class="language-cpp">SimpleString::~SimpleString()</code></pre>
</div>
<p>
    Destructor for the <code class="language-cpp">SimpleString</code> class; 
    deallocates any resources allocated on the free store. 
    This function is implicitly called when <code class="language-cpp">SimpleString</code> reaches the end of its lifetime, 
    or is explicitly deleted. This destructor relies on your implementation of <code class="language-cpp">Clear()</code> to function correctly.
</p>

<div class="box">
  <pre><code class="language-cpp">unsigned int SimpleString::Length() const</code></pre>
</div>
<p>
    Returns the value stored within the <i>length_</i> data member.
</p>

<div class="box">
  <pre><code class="language-cpp">char* SimpleString::String()</code></pre>
</div>
<p>
    Returns a pointer to the <i>string_</i> data member.
</p>

<div class="box">
  <pre><code class="language-cpp">friend std::ostream& operator&lt;&lt;(std::ostream& os, const SimpleString& s);</code></pre>
</div>
<p>
    Inserts the contents of the <i>string_ </i> data member into the specified output stream.
</p>




<hr>

<h3>Functions to Implement:</h3>

<div class="box">
  <pre><code class="language-cpp">SimpleString::SimpleString(const char* init_string)</code></pre>
</div>
<p>
    Initializes a new <code class="language-cpp">SimpleString</code> object with the passed in <i>init_string</i>. 
    Upon completed execution, the <i>string_</i> data member should point to a C-string allocated on the free store, 
    containing the same values as <i>init_string</i>. Additionally, you must also ensure that <i>length_</i> is updated properly. 
    Note that <i>length_</i> is the number of characters within the string, <b><i>not</i></b> including the sentinel value.
    If a null <i>init_string</i> is passed in, throw an <code class="language-cpp">std::invalid_argument</code> exception. 
    Pay close attention to the size <i>string_</i> should be allocated to. 
    <i>Hint: what is the size of a C-string in relation to the number of characters that are stored?</i>
</p>

<div class="box">
  <pre><code class="language-cpp">void SimpleString::Clear()</code></pre>
</div>

<p>
    Deallocates <i>string_</i>, and sets <i>length_</i> to 0. 
    Ensure no dangling pointers are left behind. 
</p>

<div class="box">
  <pre><code class="language-cpp">SimpleString& SimpleString::operator+=(char c)</code></pre>
</div>

<p>
    Appends the passed in character, <i>c</i>, to the end of the <i>string_</i> data member and adjusts <i>length_</i> accordingly.
    Allocate a new char array with enough space to store the new character. 
    Copy over the existing contents within <i>string_</i>, along with the additional character. 
    Delete the old char array, and set <i>string_</i> to the newly allocated array. 
    Ensure that the sentinel value is properly set. 
    Throw an <code class="language-cpp">std::invalid_argument</code> exception if '\0' is passed in.
</p>

<div class="box">
  <pre><code class="language-cpp">SimpleString& SimpleString::operator+=(const SimpleString& to_append)</code></pre>
</div>

<p>
    Appends the contents of the char array contained within <i>to_append</i> to the end of the <i>string_</i> data member and adjusts length_ accordingly.
    Allocate a new char array with enough space to store the additional characters within <i>to_append</i>. 
    Copy over the existing contents within <i>string_</i>, along with the additional characters. 
    Delete the old char array, and set <i>string_</i> to the newly allocated array. 
    Ensure that the sentinel value is properly set.
    <i>Hint: appending the same <code class="language-cpp">SimpleString</code> object to itself is a valid operation!</i>
</p>

<div class="box">
  <pre><code class="language-cpp">void SimpleString::ReplaceAll(const char* target, const char* replacement)</code></pre>
</div>
<p>
    Replaces all instances of the passed in <i>target</i> substring within the <i>string_</i> data member with <i>replacement</i>.
    Matches to <i>target</i> are not case sensitive. You may find <code class="language-cpp"><a href="https://en.cppreference.com/w/cpp/string/byte/tolower.html">std::tolower</a></code> useful.
    Iterate over <i>string_</i>, checking for matches with <i>target</i> at each step. 
    If a full match is found, replace <i>target</i> with <i>replacement</i> and iterate forwards. 
    If either <i>target</i> or <i>replacement</i> are null, throw an <code class="language-cpp">std::invalid_argument</code> exception. 
    Additionally, throw <code class="language-cpp">std::invalid_argument</code> if no replacements were made. 
    <i>Hint: you can create and use a separate instance of your <code class="language-cpp">SimpleString</code> class within this function.
    You have already defined behaviors that allow you to build a new string by appending single characters or strings!
    </i>
</p>
<hr>





<h3>How to compile and run driver.cc</h3>

<p>To compile the executable, run the following command in the terminal that will create an executable named <code class="language-cpp">exec</code> in your bin folder:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ make exec</kbd><br/>

<p>To run the executable, use:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ ./bin/exec</kbd><br/>

<h3>How to compile and run tests.cc</h3>

<p>To compile the tests, use the following command that will create an executable named <code class="language-cpp">tests</code> in your bin folder:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ make tests</kbd><br/>

<p>To run the tests, use:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ ./bin/tests</kbd><br/>