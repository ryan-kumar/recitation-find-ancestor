<style>
    /* Styling the responsive image grid */
    .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Adjusts column number based on screen width */
        gap: 10px;
    }
    .image-grid img {
        width: 100%;
        height: auto;
        display: block;
    }
    .important {
    background-color: #ffe6e6; 
    border-left: 5px solid #ff4d4d; 
    padding: 10px;
    margin-bottom: 20px;
    color: #000; 
    transition: background-color 0.3s, border-color 0.3s, color 0.3s; 
    } 
     
     .note {
    background-color: #ffe6e6; 
    border-left: 5px solid #4d94ff;
    padding: 10px;
    margin-bottom: 20px;
    color: #000; 
    transition: background-color 0.3s, border-color 0.3s, color 0.3s; 
  }

/* Dark mode */
@media (prefers-color-scheme: dark) {
    .important {
        background-color: #8B0000; 
        border-left: 5px solid #ff7878; 
        color: #fff; 
        width: fit-content;
    }
     .note {
        background-color: #00008B; 
        border-left: 5px solid #4d94ff; 
        color: #fff; 
        width: fit-content;
    }
}
    body {
        margin: 20px;
        font-family: Arial, sans-serif;
    }

.imgcontainer {
    display: flex;
    justify-content: center;
}
</style>

<p> In recent lesson activities, you have 
    been working with Binary Search Trees to store and manage arbitrary data. 
    We know that Binary Search trees allow us to quickly query for nodes of interest, 
    due to their unique organizational property that halves the possible search space at each step in a given traversal.
    <br><br>Recall the BST property is as follows:
</p>
 <div class="note">
        <p>Let x be a node in the BST. If y is a node in the left subtree of x, then y.value < x.value. If y is a node in the right subtree of x, then y.value >= x.value.
        </p>
    </div>
<p>
    Binary Search Trees (and all other trees) also provide additional 
 functionality through the hierarchical ordering of their nodes. 
    This allows us to model a number of interesting structures in which 
    the children of a given parent node are connected by some underlying characteristic. 
    In this activity, we will use a BST to model a Cultivar Group tree. 
</p>

<p>
    A cultivar is a variety of a plant that has been genetically 
    selected for and cultivated by humans due to its expression of desirable or otherwise novel traits. 
    Cultivars are originally derived from a naturally occurring variety of plant. 
    Due to this, cultivar groups lend themselves well to being represented as trees, such as the following example:
</p>


<div class="imgcontainer"><img src="img/cultivar_tree.png" alt=""></div>

<h3>Allowed Headers:</h3>
<p>You may only include the following headers in your solution:</p>
<ul>
  <li><code class="language-cpp">"cultivar_tree.hpp"</code></li>
  <li><code class="language-cpp">"node.hpp"</code></li>
  <li><code class="language-cpp">&lt;ostream&gt;</code></li>
  <li><code class="language-cpp">&lt;fstream&gt;</code></li>
  <li><code class="language-cpp">&lt;string&gt;</code></li>
  <li><code class="language-cpp">&lt;vector&gt;</code></li>
  <li><code class="language-cpp">&lt;iostream&gt;</code></li>
  <li><code class="language-cpp">&lt;iomanip&gt;</code></li>
  <li><code class="language-cpp">&lt;sstream&gt;</code></li>
</ul>

<p>
     Note that while we will be depicting our Cultivar Tree as a BST, 
        this not necessarily in line with most broadly accepted depictions. 
</p>

<hr>
<h3>Provided Functions:</h3>
<div class="box">
  <pre><code class="language-cpp">CultivarTree::~CultivarTree()</code></pre>
</div>
<p>
    Destructor for the <code class="language-cpp">CultivarTree</code> class; 
    deallocates any resources allocated on the free store. 
    This function is implicitly called when <code class="language-cpp">CultivarTree</code> reaches the end of its lifetime, 
    or is explicitly deleted.
</p>

<div class="box">
  <pre><code class="language-cpp">std::vector<Node*> CultivarTree::NodesFromFile(const std::string& file_name)</code></pre>
</div>
<p>
    Returns an std::vector of pointers to Nodes that have been allocated on 
    the free store, from a file that defines the structure of a given Cultivar Tree. 
    Files accepted by this function are in the following format,
     where the first value on each row denotes the <i>label_</i> of a given node, and the second value denotes the <i>key_</i>.

</p>
<div class="box">
  <pre><code class="language-cpp">    "Brassica oleracea" 10
    "Leaf Group" 8
    "Inflorescence Group" 12
    "Kale" 6
    "Cabbage" 9
    "Broccoli" 11
    "Cauliflower" 14
     </code></pre>
</div>

<div class="box">
  <pre><code class="language-cpp">std::ostream& operator&lt;&lt;(std::ostream& os, CultivarTree& ct);</code></pre>
</div>
<p>
    Inserts a representation of the specified <code class="language-cpp">CultivarTree</code> object into the desired output stream.
</p>

<hr>

<h3>Functions to Implement:</h3>

<div class="box">
  <pre><code class="language-cpp">CultivarTree::CultivarTree(const std::string& file_name);</code></pre>
</div>
<p>
    Initializes a new <code class="language-cpp">CultivarTree</code> object 
    storing the nodes as specified by the provided <i>file_name</i>. 
    You will need to use the provided 'NodesFromFile' function 
    in order to parse the specified file data into an <code class="language-cpp">std::vector</code> 
    storing the Nodes that will make up the given <code class="language-cpp">CultivarTree</code> instance. 
    After the nodes have been obtained, you must sequentially insert each one into the tree, 
    upholding the BST property as specified earlier. You will use the <i>key_</i> 
    data member stored within each node to accomplish this. <i>Hint: you may (or may not, depending on your preference) 
    want to define a helper function to aid in your implementation of this function.</i>
</p>
<p>Here is a visual example of the structure of a given Cultivar Tree:</p>
<div class="box">
  <pre><code class="language-cpp">(10: Brassica oleracea)
 l--[L](8: Leaf Group)
 |   l--[L](6: Kale)
 |   |   l--[L]____
 |   |   l--[R]____
 |   l--[R](9: Cabbage)
 |       l--[L]____
 |       l--[R]____
 l--[R](12: Inflorescence Group)
     l--[L](11: Broccoli)
     |   l--[L]____
     |   l--[R]____
     l--[R](14: Cauliflower)
         l--[L]____
         l--[R]____
  </code></pre>
</div>

<div class="box">
  <pre><code class="language-cpp">std::string CultivarTree::LowestCommonAncestor(Node* cultivar_one,
    Node* cultivar_two);</code></pre>
</div>

<p>
    Returns the <i>label_</i> of the node that is the lowest common ancestor of 
    <i>cultivar_one</i> and <i>cultivar_two</i>. 
    The lowest common ancestor is defined as the deepest possible node in a given tree, of which 
    <i>cultivar_one</i> and <i>cultivar_two</i> are descendants of. 
    It is guaranteed that <i>cultivar_one</i> and <i>cultivar_two</i> will be leaf nodes. 
    Note that for the purposes of this function, it is possible for a given node to be a descendant of itself.
    
    If either <i>cultivar_one</i> or 
    <i>cultivar_two</i> are nullptr, throw an <code class="language-cpp">std::invalid_argument</code> exception.
</p>

<h4>Example Cases:</h4>
Given the following Cultivar Tree:

<div class="box">
  <pre><code class="language-cpp">(50: Malus domestica)
    l--[L](40: Heritage Group)
    |   l--[L](35: Granny Smith)
    |   |   l--[L]____
    |   |   l--[R]____
    |   l--[R](45: McIntosh)
    |       l--[L]____
    |       l--[R]____
    l--[R](60: Modern Group)
        l--[L](55: Fuji)
        |   l--[L]____
        |   l--[R]____
        l--[R](70: Honeycrisp)
            l--[L]____
            l--[R]____
  </code></pre>
</div>

<p>Calling <code class="language-cpp">LowestCommonAncestor</code> with the Node pointers respective to "Fuji" & "Honeycrisp" returns "Modern Group".</p>

<p>Calling <code class="language-cpp">LowestCommonAncestor</code> with the Node pointers respective to "Fuji" & "McIntosh" returns "Malus domestica".</p>

<p>Calling <code class="language-cpp">LowestCommonAncestor</code> with the Node pointers respective to "Modern Group" & "Honeycrisp" returns "Modern Group".</p>

<hr>





<h3>How to compile and run driver.cc</h3>

<p>To compile the executable, run the following command in the terminal that will create an executable named <code class="language-cpp">exec</code> in your bin folder:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ make exec</kbd><br/>

<p>To run the executable, use:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ ./bin/exec</kbd><br/>

<h3>How to compile and run tests.cc</h3>

<p>To compile the tests, use the following command that will create an executable named <code class="language-cpp">tests</code> in your bin folder:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ make tests</kbd><br/>

<p>To run the tests, use:</p>
<kbd class="d-block bg-light text-dark py-2 px-3 mb-3 border">$ ./bin/tests</kbd><br/>